/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file outputs.c
 *
 * @author Christopher A. Bohn
 *
 * @brief Functions to display the message editor's contents and to send the
 *      message to the host computer.
 *
 ******************************************************************************/

/*
 * InterruptLab (c) 2021-24 Christopher A. Bohn
 * Number Pad Texter (c) 2023-24 Christopher A. Bohn
 *
 * Assignment and starter code licensed under the Apache License,
 * Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <CowPi.h>
#include <string.h>
#if defined (ARDUINO_RASPBERRY_PI_PICO)
#include <OneBitDisplay.h>
#endif //PICO
#include "outputs.h"

#if defined (ARDUINO_AVR_NANO)
static FILE *display;
#elif defined (ARDUINO_RASPBERRY_PI_PICO)
static void initialize_ssd1306(void);
static void display_string(int row, char const string[]);
#else
#error Unknown board!
#endif // WHICH BOARD IS BEING USED?


/**
 * Configures the display module, along with the rest of the Cow Pi hardware.
 */
void initialize_display(void) {
#if defined (ARDUINO_AVR_NANO)
    display = cowpi_setup(9600,
                          cowpi_configure_lcd_character_display(),
                          cowpi_configure_i2c(cowpi_discover_i2c_address(SDA, SCL))
    );
    if (display == NULL) {
        int i2c_configuration_line = __LINE__ - 3;
        fprintf_P(stderr, PSTR("Display was not configured!\n ***"));
        int8_t i2c_address = cowpi_discover_i2c_address(SDA, SCL);
        if (i2c_address == 0) {
            fprintf_P(stderr, PSTR("No I2C device detected.\n"));
        } else if (i2c_address == -1) {
            fprintf_P(stderr, PSTR("Multiple I2C devices detected.\n"));
            fprintf_P(stderr, PSTR("Modify line %d to hard-code the correct I2C address.\n"), i2c_configuration_line);
        } else {
            fprintf_P(stderr, PSTR("This does not appear to be an I2C problem.\n"));
        }
        fprintf_P(stderr, PSTR("\nRe-assigning display module's output to the console\n"));
        fprintf_P(stderr, PSTR("so that you can work on other parts of the assignment.\n\n"));
        display = stdout;
    }
#elif defined (ARDUINO_RASPBERRY_PI_PICO)
    cowpi_setup(0,
            (cowpi_display_module_t) {.display_module = NO_MODULE},
            (cowpi_display_module_protocol_t) {.protocol = NO_PROTOCOL}
    );
    initialize_ssd1306();
#endif // WHICH BOARD IS BEING USED?
}

/**
 * Sends the message to the host computer, simulating the transmission of an SMS message.
 * @param message The string to be sent to the host computer
 * @param maximum_message_length An upper bound on the length of the buffer (including the terminal NUL)
 */
void transmit_message(char message[], int8_t maximum_message_length) {
    size_t actual_message_length = strlen(message);
    // replace underscores with spaces
    message[maximum_message_length - 1] = '\0';
    char *space_character;
    while ((space_character = (char *) memchr(message, '_', maximum_message_length))) {
        *space_character = ' ';
    }
#if defined (ARDUINO_AVR_NANO)
    // send the message to the Serial Monitor
    printf_P(PSTR("Message is %d characters\n"), actual_message_length);
    printf_P(PSTR("%s\n"), message);
#elif defined (ARDUINO_RASPBERRY_PI_PICO)
    // send the message to the bottom of the display module
    static char buffer[17] = {0};
    sprintf(buffer, "%-16.16s", message);
    display_string(6, buffer);
    if (actual_message_length > 16 && actual_message_length < 30) {
        sprintf(buffer, "%-14.14s%2d", message + 16, actual_message_length);
    } else {
        sprintf(buffer, "%16d", actual_message_length);
    }
    display_string(7, buffer);
#endif // WHICH BOARD IS BEING USED?
}

/**
 * Displays up to 16 characters on the display's top row, along with a carat as the cursor on the bottom row.
 * @param message The start of the string to be displayed
 * @param cursor_position The column in which the carat should be placed; 0 is the leftmost column and 15 is the rightmost column
 */
void update_display(const char message[], int8_t cursor_position) {
#if defined (ARDUINO_AVR_NANO)
    // the message
    fprintf(display, "%-16.16s\n", message);
    // the cursor
            // printf can't do variable-width conversions on AVR targets, so we'll insert one space at a time
    for (int8_t i = 0; i < cursor_position; i++) {
        fprintf(display, " ");
    }
    fprintf(display, "^\n\f");
#elif defined (ARDUINO_RASPBERRY_PI_PICO)
    static char buffer[17] = {0};
    // the message
    sprintf(buffer, "%-16.16s", message);
    display_string(0, buffer);
    // the cursor
            // printf can't do variable-width conversions on AVR targets, so we'll insert one space at a time
    for (int8_t i = 0; i < cursor_position; i++) {
        buffer[i] = ' ';
    }
    buffer[cursor_position] = '^';
    buffer[cursor_position + 1] = '\0';
    display_string(1, buffer);
#endif // WHICH BOARD IS BEING USED?
}


#if defined (ARDUINO_RASPBERRY_PI_PICO)

/************************/
/***** SSD1306 CODE *****/
/************************/

static uint8_t backbuffer[1024] = {0};
static OBDISP display;
static bool display_needs_refreshed;

static void initialize_ssd1306(void) {
    obdI2CInit(&display, OLED_128x64, -1, 0, 0, 1, -1, -1, -1, 400000L);
    obdSetBackBuffer(&display, backbuffer);
    obdFill(&display, OBD_WHITE, 0);
    display_needs_refreshed = true;
}

static void display_string(int row, char const string[]) {
    static char rows[8][17] = {
            {"                "}, {"                "}, {"                "}, {"                "},
            {"                "}, {"                "}, {"                "}, {"                "}
    };
    if (0 <= row && row < 8) {
        sprintf(rows[row], "%-16s", string);
    }
    obdWriteString(&display, 0, 0, 8 * row, rows[row], FONT_8x8, OBD_BLACK, 0);
    display_needs_refreshed = true;
}

void refresh_display(void) {
    if (display_needs_refreshed) {
        obdDumpBuffer(&display, backbuffer);
        display_needs_refreshed = false;
    }
}

#endif //PICO

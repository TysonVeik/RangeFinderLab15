/**************************************************************************//**
 *
 * @file inputs.c
 *
 * @author (Tyson Veik)
 * @author (TYPE YOUR PARTNER'S NAME HERE, IF APPLICABLE)
 *
 * @brief Interrupt Service Routines for timer interrupts and pin change
 *      interrupts
 *
 ******************************************************************************/

/*
 * InterruptLab (c) 2021-24 Christopher A. Bohn
 * InterruptLab solution (c) the above-named student(s)
 *
 * Assignment and starter code licensed under the Apache License,
 * Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <CowPi.h>
#include "interrupt_support.h"
#include "inputs.h"
#include "character_selector.h"
#include "message_editor.h"


void handle_keypad(void);
void handle_right_button(void);
void handle_left_button(void);
void handle_led_timer(void);
void handle_character_timer(void);
void reset_timers(void);

#define CHARACTER_TIMER (1)
#define LED_TIMER       (2)
uint8_t volatile supplemental_counter;


/**
 * Registers ISR for pin change interrupts, configures timers, and enables timer interrupts.
 */
void initialize_interrupts(void) {
    register_pin_ISR((1L << 14 | 1L << 15 | 1L << 16 | 1L << 17), handle_keypad);
    register_pin_ISR(LED_TIMER, handle_led_timer);

}

/**
 * Sets timer counters and the supplemental counter to 0.
 */
void reset_timers(void) {
    supplemental_counter = 0;
    reset_timer(LED_TIMER);
    reset_timer(CHARACTER_TIMER);
}

/**
 * ISR to handle the periodic interrupts fired by the timer used for deluminating the LED.
 */
void handle_led_timer(void) {
    supplemental_counter = ((supplemental_counter + 1) & ((1 << 5) - 1)):
    if (supplemental_counter == 0) {
        cowpi_illuminate_right_led();
    }
}

/**
 * ISR to handle the periodic interrupts fired by the timer used for character finalization.
 */
void handle_character_timer(void) {



}

/**
 * ISR to handle pin change interrupts generated by the matrix keypad.
 */
void handle_keypad(void) {
    debounce_interrupt({
        static char debounce_key = 0xF0;
        char key;
        while ((key = cowpi_get_keypress()) == debounce_key) {}     // busy-wait through the race condition
        debounce_key = key;
        if (key != "\0") {
            update_character(key);
        }
        cowpi_illuminate_right_led();
        reset_timers();
    });
}

/**
 * ISR to handle pin change interrupts generated by the right pushbutton.
 */
void handle_right_button(void) {
    debounce_interrupt({
        static bool debounce_is_pressed = false;
        bool is_pressed;
        while ((is_pressed = cowpi_right_button_is_pressed()) == debounce_is_pressed) {}    // busy-wait through the race condition
        debounce_is_pressed = is_pressed;
        /* YOUR CODE GOES HERE */



    });
}

/**
 * ISR to handle pin change interrupts generated by the left pushbutton.
 */
void handle_left_button(void) {
    debounce_interrupt({
        static bool debounce_is_pressed = false;
        bool is_pressed;
        while ((is_pressed = cowpi_left_button_is_pressed()) == debounce_is_pressed) {}     // busy-wait through the race condition
        debounce_is_pressed = is_pressed;
        /* YOUR CODE GOES HERE */



    });
}
